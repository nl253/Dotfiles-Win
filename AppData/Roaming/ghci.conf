-- vim:ft=haskell:
:set prompt "\n ghci Î» "
:set prompt-cont " block >> "
:set +m
:def hoogle (\str -> return $ ":! hoogle --count=15 " ++ show str)
:def haskell_files (\str -> return ":! find -name '*.hs'")
:def vim (\str -> return (":! $EDITOR " ++ str ))

import Control.Category ((<<<), (>>>), id, (.))

:module + Data.Eq Data.Ord Data.Bool Data.Semigroup Data.Functor Data.Bifunctor Data.Bitraversable Data.Traversable Data.Maybe Data.Tuple Data.Either Data.Foldable
:module + Control.Arrow Data.Binary Data.Functor.Compose Data.Functor.Identity Data.Functor.Constant Data.Functor.Reverse Data.Functor Data.Bits Control.DeepSeq Data.Ratio System.Directory Data.Ix System.Exit Data.Traversable Debug.Trace System.Environment Text.Show.Functions Data.Word System.FilePath
:module + Data.Default Data.AEq Data.Biapplicative

putStrLn ""

:set -XFlexibleContexts  -XFlexibleInstances -XOverloadedStrings -XOverloadedLists
-- :set -XBangPatterns -XPatternGuards -XApplicativeDo -XBinaryLiterals -XDeriveAnyClass -XScopedTypeVariables -XDeriveGeneric -XDeriveFoldable -XDeriveFunctor -XDeriveTraversable -XEmptyDataDecls -XFunctionalDependencies -XGADTs -XKindSignatures -XLambdaCase -XMonadComprehensions -XMultiParamTypeClasses -XMultiWayIf -XNamedWildCards -XNumDecimals -XParallelListComp -XPartialTypeSignatures -XPostfixOperators -XTupleSections -XTypeOperators -XViewPatterns 
:set -XBangPatterns -XApplicativeDo -XBinaryLiterals -XDeriveGeneric -XDeriveFoldable -XDeriveFunctor -XDeriveTraversable -XEmptyDataDecls -XKindSignatures -XMonadComprehensions -XNamedWildCards -XNumDecimals -XParallelListComp -XPartialTypeSignatures -XPostfixOperators -XTupleSections -XTypeOperators

import qualified Prelude as P
import Text.Show (show, Show)
import GHC.Base (assert)
import Text.Read (Read, read)
import Prelude (Ordering, (*), (**), (-), (+), compare, error, fail, even, odd, pi, realToFrac, recip, round, toEnum, toInteger, toRational, exp, floor, Bounded, Fractional, rem, read, readLn, print, succ, pred, ($), (>), (<), (>=), (<=), (/), Enum, flip, const, Num, Ord, Functor, Integer, Integral, Floating, Float, Double)
import Data.Function hiding (id, (.))
import Control.Applicative (pure, Applicative, liftA, liftA2, liftA3, (<**>), (<*>), ZipList, empty, Alternative, (<|>))
import Control.Exception (catch)
import Control.Exception (try, tryJust)
import Control.Monad ((>>=), (=<<), Monad, MonadPlus, unless, join, (>=>), (<=<), void, mzero, forM, forM_, liftM, liftM2, liftM3, foldM, mfilter)
import Control.Monad.Zip (mzip, mzipWith, munzip)
import Control.Monad.Catch
import Control.Monad.Fix
import Control.Monad.Fail
import Control.Monad.Combinators
import Data.Bifunctor (Bifunctor, first, second, bimap)
import Data.Functor (void, ($>), (<$), (<$>))
import Data.Int (Int, Int8, Int16, Int32, Int64)  
import Data.Monoid (Monoid, mempty, mconcat)
import Data.Traversable (for)
import System.IO hiding (readFile, writeFile, appendFile)
import System.IO.Error (tryIOError)
import System.Process (runCommand, env, cwd, runInteractiveCommand, spawnCommand)
import System.Random (getStdGen, mkStdGen, random, randomRs)

import Text.Printf (printf)
import Data.Char hiding (ClosePunctuation, ConnectorPunctuation, Control, CurrencySymbol, DashPunctuation, DecimalNumber, EnclosingMark, FinalQuote, Format, GeneralCategory, InitialQuote, LetterNumber, LineSeparator, LowercaseLetter, MathSymbol, ModifierLetter, ModifierSymbol, NonSpacingMark, NotAssigned, OpenPunctuation, OtherLetter, OtherNumber, OtherPunctuation, OtherSymbol, ParagraphSeparator, PrivateUse, Space, SpacingCombiningMark, Surrogate, TitlecaseLetter, UppercaseLetter)

-- Collections
import qualified Data.Sequence  as Seq
import qualified Data.Set       as S
import qualified Data.Vector    as V
import qualified Data.Map       as M
import qualified Data.Array     as A
import qualified Data.ByteArray as A
import qualified Data.DList     as DL
import qualified Data.List      as L
import qualified Data.HashSet   as HS
-- import Data.List ((\\) , delete , deleteFirstsBy , dropWhileEnd , elemIndices , elemIndex , find , genericDrop , genericIndex , genericLength , genericReplicate , genericSplitAt , genericTake , group , inits , intersectBy , insert , intercalate , intersect , intersperse , isInfixOf , isPrefixOf , isSubsequenceOf , isSuffixOf , mapAccumL , mapAccumR , maximumBy , minimumBy , nub , nubBy , partition , permutations , sort , sortBy , sortOn , stripPrefix , subsequences , tails , transpose , uncons , unfoldr , union , unionBy)

-- UTF-8
import qualified Data.ByteString            as BS
import qualified Data.ByteString.Char8      as C
import qualified Data.ByteString.Lazy       as BL
import qualified Data.ByteString.Lazy.Char8 as CL

-- UNICODE
{-import qualified Data.Text as T-}
{-import qualified Data.Text.Lazy as TL-}
{-import qualified Data.Text.IO as TIO-}
{-import qualified Data.Text.Lazy.IO as TLIO-}

-- import qualified Text.Parsec as Parsec

-- not safe for empty Foldable
sconcat xs = foldl1 (<>) xs 
mconcat xs = Data.Foldable.foldl (<>) mempty xs 
mtimes = mtimesDefault

map = fmap

-- more general filter 
filter p = foldMap (\a -> if p a then pure a else mempty)
concatMap = foldMap

-- instance Bifunctor (Functor ((,,) a b)) where 
  -- bimap f g = fmap (\(x, y) -> (f x, y)) $ fmap (\(x, y) -> (x, g y))
  -- first f = \(x, y) -> (f x, y)
  -- second f = \(x, y) -> (x, f y)

-- instance Bifunctor (Foldable (Bifunctor a b)) where 
  -- bimap f g = fmap (\(x, y) -> (f x, y)) $ fmap (\(x, y) -> (x, g y))
  -- first f = \(x, y) -> (f x, y)
  -- second f = \(x, y) -> (x, f y)

-- maps for non-functors
-- for foldable of items such that (foldable item) forms a monoid
mmap funct = foldl  (\newFunctor -> (\x -> newFunctor <> (pure (funct x)))) mempty
-- for foldable of items such that (foldable item) forms a semigroup
smap funct = foldl1 (\newFunctor -> (\x -> newFunctor <> (pure (funct x))))
